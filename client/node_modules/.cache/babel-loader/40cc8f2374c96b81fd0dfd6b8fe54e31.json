{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { equal } from '@wry/equality';\nimport { execute } from \"../link/core/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, removeConnectionDirectiveFromDocument, canUseWeakMap, Observable, asyncMap, isNonEmptyArray, Concast, makeUniqueId, isDocumentNode, isNonNullObject } from \"../utilities/index.js\";\nimport { ApolloError, isApolloError } from \"../errors/index.js\";\nimport { ObservableQuery, applyNextFetchPolicy } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { LocalState } from \"./LocalState.js\";\nimport { QueryInfo, shouldWriteResult } from \"./QueryInfo.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar QueryManager = function () {\n  function QueryManager(_a) {\n    var cache = _a.cache,\n        link = _a.link,\n        _b = _a.queryDeduplication,\n        queryDeduplication = _b === void 0 ? false : _b,\n        onBroadcast = _a.onBroadcast,\n        _c = _a.ssrMode,\n        ssrMode = _c === void 0 ? false : _c,\n        _d = _a.clientAwareness,\n        clientAwareness = _d === void 0 ? {} : _d,\n        localState = _a.localState,\n        assumeImmutableResults = _a.assumeImmutableResults;\n    this.clientAwareness = {};\n    this.queries = new Map();\n    this.fetchCancelFns = new Map();\n    this.transformCache = new (canUseWeakMap ? WeakMap : Map)();\n    this.queryIdCounter = 1;\n    this.requestIdCounter = 1;\n    this.mutationIdCounter = 1;\n    this.inFlightLinkObservables = new Map();\n    this.cache = cache;\n    this.link = link;\n    this.queryDeduplication = queryDeduplication;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({\n      cache: cache\n    });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n\n    if (this.onBroadcast = onBroadcast) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n\n  QueryManager.prototype.stop = function () {\n    var _this = this;\n\n    this.queries.forEach(function (_info, queryId) {\n      _this.stopQueryNoBroadcast(queryId);\n    });\n    this.cancelPendingFetches(__DEV__ ? new InvariantError('QueryManager stopped while query was in flight') : new InvariantError(14));\n  };\n\n  QueryManager.prototype.cancelPendingFetches = function (error) {\n    this.fetchCancelFns.forEach(function (cancel) {\n      return cancel(error);\n    });\n    this.fetchCancelFns.clear();\n  };\n\n  QueryManager.prototype.mutate = function (_a) {\n    var mutation = _a.mutation,\n        variables = _a.variables,\n        optimisticResponse = _a.optimisticResponse,\n        updateQueries = _a.updateQueries,\n        _b = _a.refetchQueries,\n        refetchQueries = _b === void 0 ? [] : _b,\n        _c = _a.awaitRefetchQueries,\n        awaitRefetchQueries = _c === void 0 ? false : _c,\n        updateWithProxyFn = _a.update,\n        onQueryUpdated = _a.onQueryUpdated,\n        _d = _a.errorPolicy,\n        errorPolicy = _d === void 0 ? 'none' : _d,\n        fetchPolicy = _a.fetchPolicy,\n        keepRootFields = _a.keepRootFields,\n        context = _a.context;\n    return __awaiter(this, void 0, void 0, function () {\n      var mutationId, mutationStoreValue, self;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            __DEV__ ? invariant(mutation, 'mutation option is required. You must specify your GraphQL document in the mutation option.') : invariant(mutation, 15);\n            __DEV__ ? invariant(!fetchPolicy || fetchPolicy === 'no-cache', \"Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.\") : invariant(!fetchPolicy || fetchPolicy === 'no-cache', 16);\n            mutationId = this.generateMutationId();\n            mutation = this.transform(mutation).document;\n            variables = this.getVariables(mutation, variables);\n            if (!this.transform(mutation).hasClientExports) return [3, 2];\n            return [4, this.localState.addExportedVariables(mutation, variables, context)];\n\n          case 1:\n            variables = _e.sent();\n            _e.label = 2;\n\n          case 2:\n            mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {\n              mutation: mutation,\n              variables: variables,\n              loading: true,\n              error: null\n            });\n\n            if (optimisticResponse) {\n              this.markMutationOptimistic(optimisticResponse, {\n                mutationId: mutationId,\n                document: mutation,\n                variables: variables,\n                fetchPolicy: fetchPolicy,\n                errorPolicy: errorPolicy,\n                context: context,\n                updateQueries: updateQueries,\n                update: updateWithProxyFn,\n                keepRootFields: keepRootFields\n              });\n            }\n\n            this.broadcastQueries();\n            self = this;\n            return [2, new Promise(function (resolve, reject) {\n              return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), {\n                optimisticResponse: optimisticResponse\n              }), variables, false), function (result) {\n                if (graphQLResultHasError(result) && errorPolicy === 'none') {\n                  throw new ApolloError({\n                    graphQLErrors: result.errors\n                  });\n                }\n\n                if (mutationStoreValue) {\n                  mutationStoreValue.loading = false;\n                  mutationStoreValue.error = null;\n                }\n\n                var storeResult = __assign({}, result);\n\n                if (typeof refetchQueries === \"function\") {\n                  refetchQueries = refetchQueries(storeResult);\n                }\n\n                if (errorPolicy === 'ignore' && graphQLResultHasError(storeResult)) {\n                  delete storeResult.errors;\n                }\n\n                return self.markMutationResult({\n                  mutationId: mutationId,\n                  result: storeResult,\n                  document: mutation,\n                  variables: variables,\n                  fetchPolicy: fetchPolicy,\n                  errorPolicy: errorPolicy,\n                  context: context,\n                  update: updateWithProxyFn,\n                  updateQueries: updateQueries,\n                  awaitRefetchQueries: awaitRefetchQueries,\n                  refetchQueries: refetchQueries,\n                  removeOptimistic: optimisticResponse ? mutationId : void 0,\n                  onQueryUpdated: onQueryUpdated,\n                  keepRootFields: keepRootFields\n                });\n              }).subscribe({\n                next: function (storeResult) {\n                  self.broadcastQueries();\n                  resolve(storeResult);\n                },\n                error: function (err) {\n                  if (mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = err;\n                  }\n\n                  if (optimisticResponse) {\n                    self.cache.removeOptimistic(mutationId);\n                  }\n\n                  self.broadcastQueries();\n                  reject(err instanceof ApolloError ? err : new ApolloError({\n                    networkError: err\n                  }));\n                }\n              });\n            })];\n        }\n      });\n    });\n  };\n\n  QueryManager.prototype.markMutationResult = function (mutation, cache) {\n    var _this = this;\n\n    if (cache === void 0) {\n      cache = this.cache;\n    }\n\n    var result = mutation.result;\n    var cacheWrites = [];\n    var skipCache = mutation.fetchPolicy === \"no-cache\";\n\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      cacheWrites.push({\n        result: result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables\n      });\n      var updateQueries_1 = mutation.updateQueries;\n\n      if (updateQueries_1) {\n        this.queries.forEach(function (_a, queryId) {\n          var observableQuery = _a.observableQuery;\n          var queryName = observableQuery && observableQuery.queryName;\n\n          if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n            return;\n          }\n\n          var updater = updateQueries_1[queryName];\n\n          var _b = _this.queries.get(queryId),\n              document = _b.document,\n              variables = _b.variables;\n\n          var _c = cache.diff({\n            query: document,\n            variables: variables,\n            returnPartialData: true,\n            optimistic: false\n          }),\n              currentQueryResult = _c.result,\n              complete = _c.complete;\n\n          if (complete && currentQueryResult) {\n            var nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables\n            });\n\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: document,\n                variables: variables\n              });\n            }\n          }\n        });\n      }\n    }\n\n    if (cacheWrites.length > 0 || mutation.refetchQueries || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {\n      var results_1 = [];\n      this.refetchQueries({\n        updateCache: function (cache) {\n          if (!skipCache) {\n            cacheWrites.forEach(function (write) {\n              return cache.write(write);\n            });\n          }\n\n          var update = mutation.update;\n\n          if (update) {\n            if (!skipCache) {\n              var diff = cache.diff({\n                id: \"ROOT_MUTATION\",\n                query: _this.transform(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true\n              });\n\n              if (diff.complete) {\n                result = __assign(__assign({}, result), {\n                  data: diff.result\n                });\n              }\n            }\n\n            update(cache, result, {\n              context: mutation.context,\n              variables: mutation.variables\n            });\n          }\n\n          if (!skipCache && !mutation.keepRootFields) {\n            cache.modify({\n              id: 'ROOT_MUTATION',\n              fields: function (value, _a) {\n                var fieldName = _a.fieldName,\n                    DELETE = _a.DELETE;\n                return fieldName === \"__typename\" ? value : DELETE;\n              }\n            });\n          }\n        },\n        include: mutation.refetchQueries,\n        optimistic: false,\n        removeOptimistic: mutation.removeOptimistic,\n        onQueryUpdated: mutation.onQueryUpdated || null\n      }).forEach(function (result) {\n        return results_1.push(result);\n      });\n\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        return Promise.all(results_1).then(function () {\n          return result;\n        });\n      }\n    }\n\n    return Promise.resolve(result);\n  };\n\n  QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n    var _this = this;\n\n    var data = typeof optimisticResponse === \"function\" ? optimisticResponse(mutation.variables) : optimisticResponse;\n    return this.cache.recordOptimisticTransaction(function (cache) {\n      try {\n        _this.markMutationResult(__assign(__assign({}, mutation), {\n          result: {\n            data: data\n          }\n        }), cache);\n      } catch (error) {\n        __DEV__ && invariant.error(error);\n      }\n    }, mutation.mutationId);\n  };\n\n  QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n    return this.fetchQueryObservable(queryId, options, networkStatus).promise;\n  };\n\n  QueryManager.prototype.getQueryStore = function () {\n    var store = Object.create(null);\n    this.queries.forEach(function (info, queryId) {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors\n      };\n    });\n    return store;\n  };\n\n  QueryManager.prototype.resetErrors = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  };\n\n  QueryManager.prototype.transform = function (document) {\n    var transformCache = this.transformCache;\n\n    if (!transformCache.has(document)) {\n      var transformed = this.cache.transformDocument(document);\n      var forLink = removeConnectionDirectiveFromDocument(this.cache.transformForLink(transformed));\n      var clientQuery = this.localState.clientQuery(transformed);\n      var serverQuery = forLink && this.localState.serverQuery(forLink);\n      var cacheEntry_1 = {\n        document: transformed,\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery: clientQuery,\n        serverQuery: serverQuery,\n        defaultVars: getDefaultValues(getOperationDefinition(transformed)),\n        asQuery: __assign(__assign({}, transformed), {\n          definitions: transformed.definitions.map(function (def) {\n            if (def.kind === \"OperationDefinition\" && def.operation !== \"query\") {\n              return __assign(__assign({}, def), {\n                operation: \"query\"\n              });\n            }\n\n            return def;\n          })\n        })\n      };\n\n      var add = function (doc) {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry_1);\n        }\n      };\n\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n\n    return transformCache.get(document);\n  };\n\n  QueryManager.prototype.getVariables = function (document, variables) {\n    return __assign(__assign({}, this.transform(document).defaultVars), variables);\n  };\n\n  QueryManager.prototype.watchQuery = function (options) {\n    options = __assign(__assign({}, options), {\n      variables: this.getVariables(options.query, options.variables)\n    });\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    var queryInfo = new QueryInfo(this);\n    var observable = new ObservableQuery({\n      queryManager: this,\n      queryInfo: queryInfo,\n      options: options\n    });\n    this.queries.set(observable.queryId, queryInfo);\n    queryInfo.init({\n      document: options.query,\n      observableQuery: observable,\n      variables: options.variables\n    });\n    return observable;\n  };\n\n  QueryManager.prototype.query = function (options, queryId) {\n    var _this = this;\n\n    if (queryId === void 0) {\n      queryId = this.generateQueryId();\n    }\n\n    __DEV__ ? invariant(options.query, 'query option is required. You must specify your GraphQL document ' + 'in the query option.') : invariant(options.query, 17);\n    __DEV__ ? invariant(options.query.kind === 'Document', 'You must wrap the query string in a \"gql\" tag.') : invariant(options.query.kind === 'Document', 18);\n    __DEV__ ? invariant(!options.returnPartialData, 'returnPartialData option only supported on watchQuery.') : invariant(!options.returnPartialData, 19);\n    __DEV__ ? invariant(!options.pollInterval, 'pollInterval option only supported on watchQuery.') : invariant(!options.pollInterval, 20);\n    return this.fetchQuery(queryId, options).finally(function () {\n      return _this.stopQuery(queryId);\n    });\n  };\n\n  QueryManager.prototype.generateQueryId = function () {\n    return String(this.queryIdCounter++);\n  };\n\n  QueryManager.prototype.generateRequestId = function () {\n    return this.requestIdCounter++;\n  };\n\n  QueryManager.prototype.generateMutationId = function () {\n    return String(this.mutationIdCounter++);\n  };\n\n  QueryManager.prototype.stopQueryInStore = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n\n  QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  };\n\n  QueryManager.prototype.clearStore = function () {\n    this.cancelPendingFetches(__DEV__ ? new InvariantError('Store reset while query was in flight (not completed in link chain)') : new InvariantError(21));\n    this.queries.forEach(function (queryInfo) {\n      if (queryInfo.observableQuery) {\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n\n    return this.cache.reset();\n  };\n\n  QueryManager.prototype.resetStore = function () {\n    var _this = this;\n\n    return this.clearStore().then(function () {\n      return _this.reFetchObservableQueries();\n    });\n  };\n\n  QueryManager.prototype.getObservableQueries = function (include) {\n    var _this = this;\n\n    if (include === void 0) {\n      include = \"active\";\n    }\n\n    var queries = new Map();\n    var queryNamesAndDocs = new Map();\n    var legacyQueryOptions = new Set();\n\n    if (Array.isArray(include)) {\n      include.forEach(function (desc) {\n        if (typeof desc === \"string\") {\n          queryNamesAndDocs.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          queryNamesAndDocs.set(_this.transform(desc).document, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.queries.forEach(function (_a, queryId) {\n      var oq = _a.observableQuery,\n          document = _a.document;\n\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n\n        var queryName = oq.queryName,\n            fetchPolicy = oq.options.fetchPolicy;\n\n        if (fetchPolicy === \"standby\" || !oq.hasObservers()) {\n          return;\n        }\n\n        if (include === \"active\" || queryName && queryNamesAndDocs.has(queryName) || document && queryNamesAndDocs.has(document)) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndDocs.set(queryName, true);\n          if (document) queryNamesAndDocs.set(document, true);\n        }\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach(function (options) {\n        var queryId = makeUniqueId(\"legacyOneTimeQuery\");\n\n        var queryInfo = _this.getQuery(queryId).init({\n          document: options.query,\n          variables: options.variables\n        });\n\n        var oq = new ObservableQuery({\n          queryManager: _this,\n          queryInfo: queryInfo,\n          options: __assign(__assign({}, options), {\n            fetchPolicy: \"network-only\"\n          })\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n\n    if (__DEV__ && queryNamesAndDocs.size) {\n      queryNamesAndDocs.forEach(function (included, nameOrDoc) {\n        if (!included) {\n          __DEV__ && invariant.warn(\"Unknown query \" + (typeof nameOrDoc === \"string\" ? \"named \" : \"\") + JSON.stringify(nameOrDoc, null, 2) + \" requested in refetchQueries options.include array\");\n        }\n      });\n    }\n\n    return queries;\n  };\n\n  QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n    var _this = this;\n\n    if (includeStandby === void 0) {\n      includeStandby = false;\n    }\n\n    var observableQueryPromises = [];\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function (observableQuery, queryId) {\n      var fetchPolicy = observableQuery.options.fetchPolicy;\n      observableQuery.resetLastResults();\n\n      if (includeStandby || fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\") {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n\n      _this.getQuery(queryId).setDiff(null);\n    });\n    this.broadcastQueries();\n    return Promise.all(observableQueryPromises);\n  };\n\n  QueryManager.prototype.setObservableQuery = function (observableQuery) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  };\n\n  QueryManager.prototype.startGraphQLSubscription = function (_a) {\n    var _this = this;\n\n    var query = _a.query,\n        fetchPolicy = _a.fetchPolicy,\n        errorPolicy = _a.errorPolicy,\n        variables = _a.variables,\n        _b = _a.context,\n        context = _b === void 0 ? {} : _b;\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n\n    var makeObservable = function (variables) {\n      return _this.getObservableFromLink(query, context, variables).map(function (result) {\n        if (fetchPolicy !== 'no-cache') {\n          if (shouldWriteResult(result, errorPolicy)) {\n            _this.cache.write({\n              query: query,\n              result: result.data,\n              dataId: 'ROOT_SUBSCRIPTION',\n              variables: variables\n            });\n          }\n\n          _this.broadcastQueries();\n        }\n\n        if (graphQLResultHasError(result)) {\n          throw new ApolloError({\n            graphQLErrors: result.errors\n          });\n        }\n\n        return result;\n      });\n    };\n\n    if (this.transform(query).hasClientExports) {\n      var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);\n      return new Observable(function (observer) {\n        var sub = null;\n        observablePromise_1.then(function (observable) {\n          return sub = observable.subscribe(observer);\n        }, observer.error);\n        return function () {\n          return sub && sub.unsubscribe();\n        };\n      });\n    }\n\n    return makeObservable(variables);\n  };\n\n  QueryManager.prototype.stopQuery = function (queryId) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n\n  QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  };\n\n  QueryManager.prototype.removeQuery = function (queryId) {\n    this.fetchCancelFns.delete(queryId);\n    this.getQuery(queryId).stop();\n    this.queries.delete(queryId);\n  };\n\n  QueryManager.prototype.broadcastQueries = function () {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(function (info) {\n      return info.notify();\n    });\n  };\n\n  QueryManager.prototype.getLocalState = function () {\n    return this.localState;\n  };\n\n  QueryManager.prototype.getObservableFromLink = function (query, context, variables, deduplication) {\n    var _this = this;\n\n    var _a;\n\n    if (deduplication === void 0) {\n      deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;\n    }\n\n    var observable;\n    var serverQuery = this.transform(query).serverQuery;\n\n    if (serverQuery) {\n      var _b = this,\n          inFlightLinkObservables_1 = _b.inFlightLinkObservables,\n          link = _b.link;\n\n      var operation = {\n        query: serverQuery,\n        variables: variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext(__assign(__assign({}, context), {\n          forceFetch: !deduplication\n        }))\n      };\n      context = operation.context;\n\n      if (deduplication) {\n        var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();\n        inFlightLinkObservables_1.set(serverQuery, byVariables_1);\n        var varJson_1 = canonicalStringify(variables);\n        observable = byVariables_1.get(varJson_1);\n\n        if (!observable) {\n          var concast = new Concast([execute(link, operation)]);\n          byVariables_1.set(varJson_1, observable = concast);\n          concast.cleanup(function () {\n            if (byVariables_1.delete(varJson_1) && byVariables_1.size < 1) {\n              inFlightLinkObservables_1.delete(serverQuery);\n            }\n          });\n        }\n      } else {\n        observable = new Concast([execute(link, operation)]);\n      }\n    } else {\n      observable = new Concast([Observable.of({\n        data: {}\n      })]);\n      context = this.prepareContext(context);\n    }\n\n    var clientQuery = this.transform(query).clientQuery;\n\n    if (clientQuery) {\n      observable = asyncMap(observable, function (result) {\n        return _this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context: context,\n          variables: variables\n        });\n      });\n    }\n\n    return observable;\n  };\n\n  QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {\n    var requestId = queryInfo.lastRequestId = this.generateRequestId();\n    return asyncMap(this.getObservableFromLink(queryInfo.document, options.context, options.variables), function (result) {\n      var hasErrors = isNonEmptyArray(result.errors);\n\n      if (requestId >= queryInfo.lastRequestId) {\n        if (hasErrors && options.errorPolicy === \"none\") {\n          throw queryInfo.markError(new ApolloError({\n            graphQLErrors: result.errors\n          }));\n        }\n\n        queryInfo.markResult(result, options, cacheWriteBehavior);\n        queryInfo.markReady();\n      }\n\n      var aqr = {\n        data: result.data,\n        loading: false,\n        networkStatus: queryInfo.networkStatus || NetworkStatus.ready\n      };\n\n      if (hasErrors && options.errorPolicy !== \"ignore\") {\n        aqr.errors = result.errors;\n      }\n\n      return aqr;\n    }, function (networkError) {\n      var error = isApolloError(networkError) ? networkError : new ApolloError({\n        networkError: networkError\n      });\n\n      if (requestId >= queryInfo.lastRequestId) {\n        queryInfo.markError(error);\n      }\n\n      throw error;\n    });\n  };\n\n  QueryManager.prototype.fetchQueryObservable = function (queryId, options, networkStatus) {\n    var _this = this;\n\n    if (networkStatus === void 0) {\n      networkStatus = NetworkStatus.loading;\n    }\n\n    var query = this.transform(options.query).document;\n    var variables = this.getVariables(query, options.variables);\n    var queryInfo = this.getQuery(queryId);\n    var _a = options.fetchPolicy,\n        fetchPolicy = _a === void 0 ? \"cache-first\" : _a,\n        _b = options.errorPolicy,\n        errorPolicy = _b === void 0 ? \"none\" : _b,\n        _c = options.returnPartialData,\n        returnPartialData = _c === void 0 ? false : _c,\n        _d = options.notifyOnNetworkStatusChange,\n        notifyOnNetworkStatusChange = _d === void 0 ? false : _d,\n        _e = options.context,\n        context = _e === void 0 ? {} : _e;\n    var normalized = Object.assign({}, options, {\n      query: query,\n      variables: variables,\n      fetchPolicy: fetchPolicy,\n      errorPolicy: errorPolicy,\n      returnPartialData: returnPartialData,\n      notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n      context: context\n    });\n\n    var fromVariables = function (variables) {\n      normalized.variables = variables;\n      return _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n    };\n\n    this.fetchCancelFns.set(queryId, function (reason) {\n      Promise.resolve().then(function () {\n        return concast.cancel(reason);\n      });\n    });\n    var concast = new Concast(this.transform(normalized.query).hasClientExports ? this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables) : fromVariables(normalized.variables));\n    concast.cleanup(function () {\n      _this.fetchCancelFns.delete(queryId);\n\n      applyNextFetchPolicy(options);\n    });\n    return concast;\n  };\n\n  QueryManager.prototype.refetchQueries = function (_a) {\n    var _this = this;\n\n    var updateCache = _a.updateCache,\n        include = _a.include,\n        _b = _a.optimistic,\n        optimistic = _b === void 0 ? false : _b,\n        _c = _a.removeOptimistic,\n        removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId(\"refetchQueries\") : void 0 : _c,\n        onQueryUpdated = _a.onQueryUpdated;\n    var includedQueriesById = new Map();\n\n    if (include) {\n      this.getObservableQueries(include).forEach(function (oq, queryId) {\n        includedQueriesById.set(queryId, {\n          oq: oq,\n          lastDiff: _this.getQuery(queryId).getDiff()\n        });\n      });\n    }\n\n    var results = new Map();\n\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n        optimistic: optimistic && removeOptimistic || false,\n        removeOptimistic: removeOptimistic,\n        onWatchUpdated: function (watch, diff, lastDiff) {\n          var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n\n          if (oq) {\n            if (onQueryUpdated) {\n              includedQueriesById.delete(oq.queryId);\n              var result = onQueryUpdated(oq, diff, lastDiff);\n\n              if (result === true) {\n                result = oq.refetch();\n              }\n\n              if (result !== false) {\n                results.set(oq, result);\n              }\n\n              return false;\n            }\n\n            if (onQueryUpdated !== null) {\n              includedQueriesById.set(oq.queryId, {\n                oq: oq,\n                lastDiff: lastDiff,\n                diff: diff\n              });\n            }\n          }\n        }\n      });\n    }\n\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(function (_a, queryId) {\n        var oq = _a.oq,\n            lastDiff = _a.lastDiff,\n            diff = _a.diff;\n        var result;\n\n        if (onQueryUpdated) {\n          if (!diff) {\n            var info = oq[\"queryInfo\"];\n            info.reset();\n            diff = info.getDiff();\n          }\n\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n\n        if (result !== false) {\n          results.set(oq, result);\n        }\n\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          _this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  };\n\n  QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a, networkStatus) {\n    var _this = this;\n\n    var query = _a.query,\n        variables = _a.variables,\n        fetchPolicy = _a.fetchPolicy,\n        refetchWritePolicy = _a.refetchWritePolicy,\n        errorPolicy = _a.errorPolicy,\n        returnPartialData = _a.returnPartialData,\n        context = _a.context,\n        notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n    var oldNetworkStatus = queryInfo.networkStatus;\n    queryInfo.init({\n      document: query,\n      variables: variables,\n      networkStatus: networkStatus\n    });\n\n    var readCache = function () {\n      return queryInfo.getDiff(variables);\n    };\n\n    var resultsFromCache = function (diff, networkStatus) {\n      if (networkStatus === void 0) {\n        networkStatus = queryInfo.networkStatus || NetworkStatus.loading;\n      }\n\n      var data = diff.result;\n\n      if (__DEV__ && isNonEmptyArray(diff.missing) && !equal(data, {}) && !returnPartialData) {\n        __DEV__ && invariant.debug(\"Missing cache result fields: \" + diff.missing.map(function (m) {\n          return m.path.join('.');\n        }).join(', '), diff.missing);\n      }\n\n      var fromData = function (data) {\n        return Observable.of(__assign({\n          data: data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus: networkStatus\n        }, diff.complete ? null : {\n          partial: true\n        }));\n      };\n\n      if (data && _this.transform(query).hasForcedResolvers) {\n        return _this.localState.runResolvers({\n          document: query,\n          remoteResult: {\n            data: data\n          },\n          context: context,\n          variables: variables,\n          onlyRunForcedResolvers: true\n        }).then(function (resolved) {\n          return fromData(resolved.data || void 0);\n        });\n      }\n\n      return fromData(data);\n    };\n\n    var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== \"merge\" ? 1 : 2;\n\n    var resultsFromLink = function () {\n      return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n        variables: variables,\n        context: context,\n        fetchPolicy: fetchPolicy,\n        errorPolicy: errorPolicy\n      });\n    };\n\n    var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === \"number\" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);\n\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\":\n        {\n          var diff = readCache();\n\n          if (diff.complete) {\n            return [resultsFromCache(diff, queryInfo.markReady())];\n          }\n\n          if (returnPartialData || shouldNotify) {\n            return [resultsFromCache(diff), resultsFromLink()];\n          }\n\n          return [resultsFromLink()];\n        }\n\n      case \"cache-and-network\":\n        {\n          var diff = readCache();\n\n          if (diff.complete || returnPartialData || shouldNotify) {\n            return [resultsFromCache(diff), resultsFromLink()];\n          }\n\n          return [resultsFromLink()];\n        }\n\n      case \"cache-only\":\n        return [resultsFromCache(readCache(), queryInfo.markReady())];\n\n      case \"network-only\":\n        if (shouldNotify) {\n          return [resultsFromCache(readCache()), resultsFromLink()];\n        }\n\n        return [resultsFromLink()];\n\n      case \"no-cache\":\n        if (shouldNotify) {\n          return [resultsFromCache(queryInfo.getDiff()), resultsFromLink()];\n        }\n\n        return [resultsFromLink()];\n\n      case \"standby\":\n        return [];\n    }\n  };\n\n  QueryManager.prototype.getQuery = function (queryId) {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n\n    return this.queries.get(queryId);\n  };\n\n  QueryManager.prototype.prepareContext = function (context) {\n    if (context === void 0) {\n      context = {};\n    }\n\n    var newContext = this.localState.prepareContext(context);\n    return __assign(__assign({}, newContext), {\n      clientAwareness: this.clientAwareness\n    });\n  };\n\n  return QueryManager;\n}();\n\nexport { QueryManager };","map":{"version":3,"sources":["../../src/core/QueryManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { DocumentNode } from 'graphql';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { equal } from '@wry/equality';\n\nimport { ApolloLink, execute, FetchResult } from '../link/core';\nimport { Cache, ApolloCache, canonicalStringify } from '../cache';\n\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasClientExports,\n  graphQLResultHasError,\n  removeConnectionDirectiveFromDocument,\n  canUseWeakMap,\n  ObservableSubscription,\n  Observable,\n  asyncMap,\n  isNonEmptyArray,\n  Concast,\n  ConcastSourcesIterable,\n  makeUniqueId,\n  isDocumentNode,\n  isNonNullObject,\n} from '../utilities';\nimport { ApolloError, isApolloError } from '../errors';\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  WatchQueryFetchPolicy,\n  ErrorPolicy,\n} from './watchQueryOptions';\nimport { ObservableQuery, applyNextFetchPolicy } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  ApolloQueryResult,\n  OperationVariables,\n  MutationUpdaterFunction,\n  OnQueryUpdated,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesOptions,\n  InternalRefetchQueriesResult,\n  InternalRefetchQueriesMap,\n} from './types';\nimport { LocalState } from './LocalState';\n\nimport {\n  QueryInfo,\n  QueryStoreValue,\n  shouldWriteResult,\n  CacheWriteBehavior,\n} from './QueryInfo';\n\nconst { hasOwnProperty } = Object.prototype;\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\ntype UpdateQueries<TData> = MutationOptions<TData, any, any>[\"updateQueries\"];\n\ninterface TransformCacheEntry {\n  document: DocumentNode;\n  hasClientExports: boolean;\n  hasForcedResolvers: boolean;\n  clientQuery: DocumentNode | null;\n  serverQuery: DocumentNode | null;\n  defaultVars: OperationVariables;\n  asQuery: DocumentNode;\n}\n\nexport class QueryManager<TStore> {\n  public cache: ApolloCache<TStore>;\n  public link: ApolloLink;\n  public readonly assumeImmutableResults: boolean;\n  public readonly ssrMode: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  // All the queries that the QueryManager is currently managing (not\n  // including mutations and subscriptions).\n  private queries = new Map<string, QueryInfo>();\n\n  // Maps from queryId strings to Promise rejection functions for\n  // currently active queries and fetches.\n  private fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor({\n    cache,\n    link,\n    queryDeduplication = false,\n    onBroadcast,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n    assumeImmutableResults,\n  }: {\n    cache: ApolloCache<TStore>;\n    link: ApolloLink;\n    queryDeduplication?: boolean;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n    assumeImmutableResults?: boolean;\n  }) {\n    this.cache = cache;\n    this.link = link;\n    this.queryDeduplication = queryDeduplication;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n    if ((this.onBroadcast = onBroadcast)) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.cancelPendingFetches(\n      new InvariantError('QueryManager stopped while query was in flight'),\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach(cancel => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>\n  >({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    onQueryUpdated,\n    errorPolicy = 'none',\n    fetchPolicy,\n    keepRootFields,\n    context,\n  }: MutationOptions<TData, TVariables, TContext>): Promise<FetchResult<TData>> {\n    invariant(\n      mutation,\n      'mutation option is required. You must specify your GraphQL document in the mutation option.',\n    );\n\n    invariant(\n      !fetchPolicy || fetchPolicy === 'no-cache',\n      \"Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.\"\n    );\n\n    const mutationId = this.generateMutationId();\n    mutation = this.transform(mutation).document;\n\n    variables = this.getVariables(mutation, variables) as TVariables;\n\n    if (this.transform(mutation).hasClientExports) {\n      variables = await this.localState.addExportedVariables(mutation, variables, context) as TVariables;\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[mutationId] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    if (optimisticResponse) {\n      this.markMutationOptimistic<\n        TData,\n        TVariables,\n        TContext,\n        TCache\n      >(optimisticResponse, {\n        mutationId,\n        document: mutation,\n        variables,\n        fetchPolicy,\n        errorPolicy,\n        context,\n        updateQueries,\n        update: updateWithProxyFn,\n        keepRootFields,\n      });\n    }\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      return asyncMap(\n        self.getObservableFromLink(\n          mutation,\n          {\n            ...context,\n            optimisticResponse,\n          },\n          variables,\n          false,\n        ),\n\n        (result: FetchResult<TData>) => {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            throw new ApolloError({\n              graphQLErrors: result.errors,\n            });\n          }\n\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = null;\n          }\n\n          const storeResult: typeof result = { ...result };\n\n          if (typeof refetchQueries === \"function\") {\n            refetchQueries = refetchQueries(storeResult);\n          }\n\n          if (errorPolicy === 'ignore' &&\n              graphQLResultHasError(storeResult)) {\n            delete storeResult.errors;\n          }\n\n          return self.markMutationResult<\n            TData,\n            TVariables,\n            TContext,\n            TCache\n          >({\n            mutationId,\n            result: storeResult,\n            document: mutation,\n            variables,\n            fetchPolicy,\n            errorPolicy,\n            context,\n            update: updateWithProxyFn,\n            updateQueries,\n            awaitRefetchQueries,\n            refetchQueries,\n            removeOptimistic: optimisticResponse ? mutationId : void 0,\n            onQueryUpdated,\n            keepRootFields,\n          });\n        },\n\n      ).subscribe({\n        next(storeResult) {\n          self.broadcastQueries();\n\n          // At the moment, a mutation can have only one result, so we can\n          // immediately resolve upon receiving the first result. In the future,\n          // mutations containing @defer or @stream directives might receive\n          // multiple FetchResult payloads from the ApolloLink chain, so we will\n          // probably need to collect those results in this next method and call\n          // resolve only later, in an observer.complete function.\n          resolve(storeResult);\n        },\n\n        error(err: Error) {\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = err;\n          }\n\n          if (optimisticResponse) {\n            self.cache.removeOptimistic(mutationId);\n          }\n\n          self.broadcastQueries();\n\n          reject(\n            err instanceof ApolloError ? err : new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n      });\n    });\n  }\n\n  public markMutationResult<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>\n  >(\n    mutation: {\n      mutationId: string;\n      result: FetchResult<TData>;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: \"no-cache\";\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      awaitRefetchQueries?: boolean;\n      refetchQueries?: InternalRefetchQueriesInclude;\n      removeOptimistic?: string;\n      onQueryUpdated?: OnQueryUpdated<any>;\n      keepRootFields?: boolean;\n    },\n    cache = this.cache,\n  ): Promise<FetchResult<TData>> {\n    let { result } = mutation;\n    const cacheWrites: Cache.WriteOptions[] = [];\n    const skipCache = mutation.fetchPolicy === \"no-cache\";\n\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      cacheWrites.push({\n        result: result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables,\n      });\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          const queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries, queryName)) {\n            return;\n          }\n          const updater = updateQueries[queryName];\n          const { document, variables } = this.queries.get(queryId)!;\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = cache.diff<TData>({\n            query: document!,\n            variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables!,\n            });\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: document!,\n                variables,\n              });\n            }\n          }\n        });\n      }\n    }\n\n    if (\n      cacheWrites.length > 0 ||\n      mutation.refetchQueries ||\n      mutation.update ||\n      mutation.onQueryUpdated ||\n      mutation.removeOptimistic\n    ) {\n      const results: any[] = [];\n\n      this.refetchQueries({\n        updateCache: (cache: TCache) => {\n          if (!skipCache) {\n            cacheWrites.forEach(write => cache.write(write));\n          }\n\n          // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n          const { update } = mutation;\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              const diff = cache.diff<TData>({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: this.transform(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true,\n              });\n\n              if (diff.complete) {\n                result = { ...result, data: diff.result };\n              }\n            }\n\n            update(cache, result, {\n              context: mutation.context,\n              variables: mutation.variables,\n            });\n          }\n\n          // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n          if (!skipCache && !mutation.keepRootFields) {\n            cache.modify({\n              id: 'ROOT_MUTATION',\n              fields(value, { fieldName, DELETE }) {\n                return fieldName === \"__typename\" ? value : DELETE;\n              },\n            });\n          }\n        },\n\n        include: mutation.refetchQueries,\n\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null,\n\n      }).forEach(result => results.push(result));\n\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results).then(() => result);\n      }\n    }\n\n    return Promise.resolve(result);\n  }\n\n  public markMutationOptimistic<TData, TVariables, TContext, TCache extends ApolloCache<any>>(\n    optimisticResponse: any,\n    mutation: {\n      mutationId: string;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: \"no-cache\";\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>,\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      keepRootFields?: boolean,\n    },\n  ) {\n    const data = typeof optimisticResponse === \"function\"\n      ? optimisticResponse(mutation.variables)\n      : optimisticResponse;\n\n    return this.cache.recordOptimisticTransaction(cache => {\n      try {\n        this.markMutationResult<TData, TVariables, TContext, TCache>({\n          ...mutation,\n          result: { data },\n        }, cache);\n      } catch (error) {\n        invariant.error(error);\n      }\n    }, mutation.mutationId);\n  }\n\n  public fetchQuery<TData, TVars>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    networkStatus?: NetworkStatus,\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.fetchQueryObservable<TData, TVars>(\n      queryId,\n      options,\n      networkStatus,\n    ).promise;\n  }\n\n  public getQueryStore() {\n    const store: Record<string, QueryStoreValue> = Object.create(null);\n    this.queries.forEach((info, queryId) => {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors,\n      };\n    });\n    return store;\n  }\n\n  public resetErrors(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  }\n\n  private transformCache = new (\n    canUseWeakMap ? WeakMap : Map\n  )<DocumentNode, TransformCacheEntry>();\n\n  public transform(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const transformed = this.cache.transformDocument(document);\n      const forLink = removeConnectionDirectiveFromDocument(\n        this.cache.transformForLink(transformed));\n\n      const clientQuery = this.localState.clientQuery(transformed);\n      const serverQuery = forLink && this.localState.serverQuery(forLink);\n\n      const cacheEntry: TransformCacheEntry = {\n        document: transformed,\n        // TODO These two calls (hasClientExports and shouldForceResolvers)\n        // could probably be merged into a single traversal.\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery,\n        serverQuery,\n        defaultVars: getDefaultValues(\n          getOperationDefinition(transformed)\n        ) as OperationVariables,\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: {\n          ...transformed,\n          definitions: transformed.definitions.map(def => {\n            if (def.kind === \"OperationDefinition\" &&\n                def.operation !== \"query\") {\n              return { ...def, operation: \"query\" };\n            }\n            return def;\n          }),\n        }\n      };\n\n      const add = (doc: DocumentNode | null) => {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry);\n        }\n      }\n      // Add cacheEntry to the transformCache using several different keys,\n      // since any one of these documents could end up getting passed to the\n      // transform method again in the future.\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables<TVariables>(\n    document: DocumentNode,\n    variables?: TVariables,\n  ): OperationVariables {\n    return {\n      ...this.transform(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  public watchQuery<T, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables, T>,\n  ): ObservableQuery<T, TVariables> {\n    // assign variable default values if supplied\n    options = {\n      ...options,\n      variables: this.getVariables(\n        options.query,\n        options.variables,\n      ) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    const queryInfo = new QueryInfo(this);\n    const observable = new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      queryInfo,\n      options,\n    });\n\n    this.queries.set(observable.queryId, queryInfo);\n\n    queryInfo.init({\n      document: options.query,\n      observableQuery: observable,\n      variables: options.variables,\n    });\n\n    return observable;\n  }\n\n  public query<TData, TVars = OperationVariables>(\n    options: QueryOptions<TVars, TData>,\n    queryId = this.generateQueryId(),\n  ): Promise<ApolloQueryResult<TData>> {\n    invariant(\n      options.query,\n      'query option is required. You must specify your GraphQL document ' +\n        'in the query option.',\n    );\n\n    invariant(\n      options.query.kind === 'Document',\n      'You must wrap the query string in a \"gql\" tag.',\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      'returnPartialData option only supported on watchQuery.',\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      'pollInterval option only supported on watchQuery.',\n    );\n\n    return this.fetchQuery<TData, TVars>(\n      queryId,\n      options,\n    ).finally(() => this.stopQuery(queryId));\n  }\n\n  private queryIdCounter = 1;\n  public generateQueryId() {\n    return String(this.queryIdCounter++);\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  private mutationIdCounter = 1;\n  public generateMutationId() {\n    return String(this.mutationIdCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  }\n\n  public clearStore(): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(new InvariantError(\n      'Store reset while query was in flight (not completed in link chain)',\n    ));\n\n    this.queries.forEach(queryInfo => {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n\n    // begin removing data from the store\n    return this.cache.reset();\n  }\n\n  public resetStore(): Promise<ApolloQueryResult<any>[]> {\n    // Similarly, we have to have to refetch each of the queries currently being\n    // observed. We refetch instead of error'ing on these since the assumption is that\n    // resetting the store doesn't eliminate the need for the queries currently being\n    // watched. If there is an existing query in flight when the store is reset,\n    // the promise for it will be rejected and its results will not be written to the\n    // store.\n    return this.clearStore().then(() => {\n      return this.reFetchObservableQueries();\n    });\n  }\n\n  public getObservableQueries(\n    include: InternalRefetchQueriesInclude = \"active\",\n  ) {\n    const queries = new Map<string, ObservableQuery<any>>();\n    const queryNamesAndDocs = new Map<string | DocumentNode, boolean>();\n    const legacyQueryOptions = new Set<QueryOptions>();\n\n    if (Array.isArray(include)) {\n      include.forEach(desc => {\n        if (typeof desc === \"string\") {\n          queryNamesAndDocs.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          queryNamesAndDocs.set(this.transform(desc).document, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.queries.forEach(({ observableQuery: oq, document }, queryId) => {\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n\n        const {\n          queryName,\n          options: { fetchPolicy },\n        } = oq;\n\n        if (fetchPolicy === \"standby\" || !oq.hasObservers()) {\n          // Skip inactive queries unless include === \"all\".\n          return;\n        }\n\n        if (\n          include === \"active\" ||\n          (queryName && queryNamesAndDocs.has(queryName)) ||\n          (document && queryNamesAndDocs.has(document))\n        ) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndDocs.set(queryName, true);\n          if (document) queryNamesAndDocs.set(document, true);\n        }\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach((options: QueryOptions) => {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        const queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        const queryInfo = this.getQuery(queryId).init({\n          document: options.query,\n          variables: options.variables,\n        });\n        const oq = new ObservableQuery({\n          queryManager: this,\n          queryInfo,\n          options: {\n            ...options,\n            fetchPolicy: \"network-only\",\n          },\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n\n    if (__DEV__ && queryNamesAndDocs.size) {\n      queryNamesAndDocs.forEach((included, nameOrDoc) => {\n        if (!included) {\n          invariant.warn(`Unknown query ${\n            typeof nameOrDoc === \"string\" ? \"named \" : \"\"\n          }${\n            JSON.stringify(nameOrDoc, null, 2)\n          } requested in refetchQueries options.include array`);\n        }\n      });\n    }\n\n    return queries;\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.getObservableQueries(\n      includeStandby ? \"all\" : \"active\"\n    ).forEach((observableQuery, queryId) => {\n      const { fetchPolicy } = observableQuery.options;\n      observableQuery.resetLastResults();\n      if (includeStandby ||\n          (fetchPolicy !== \"standby\" &&\n           fetchPolicy !== \"cache-only\")) {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n      this.getQuery(queryId).setDiff(null);\n    });\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public setObservableQuery(observableQuery: ObservableQuery<any, any>) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  }\n\n  public startGraphQLSubscription<T = any>({\n    query,\n    fetchPolicy,\n    errorPolicy,\n    variables,\n    context = {},\n  }: SubscriptionOptions): Observable<FetchResult<T>> {\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(\n        query,\n        context,\n        variables,\n      ).map(result => {\n        if (fetchPolicy !== 'no-cache') {\n          // the subscription interface should handle not sending us results we no longer subscribe to.\n          // XXX I don't think we ever send in an object with errors, but we might in the future...\n          if (shouldWriteResult(result, errorPolicy)) {\n            this.cache.write({\n              query,\n              result: result.data,\n              dataId: 'ROOT_SUBSCRIPTION',\n              variables: variables,\n            });\n          }\n\n          this.broadcastQueries();\n        }\n\n        if (graphQLResultHasError(result)) {\n          throw new ApolloError({\n            graphQLErrors: result.errors,\n          });\n        }\n\n        return result;\n      });\n\n    if (this.transform(query).hasClientExports) {\n      const observablePromise = this.localState.addExportedVariables(\n        query,\n        variables,\n        context,\n      ).then(makeObservable);\n\n      return new Observable<FetchResult<T>>(observer => {\n        let sub: ObservableSubscription | null = null;\n        observablePromise.then(\n          observable => sub = observable.subscribe(observer),\n          observer.error,\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    this.getQuery(queryId).stop();\n    this.queries.delete(queryId);\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(info => info.notify());\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  private inFlightLinkObservables = new Map<\n    DocumentNode,\n    Map<string, Observable<FetchResult>>\n  >();\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    deduplication: boolean =\n      // Prefer context.queryDeduplication if specified.\n      context?.queryDeduplication ??\n      this.queryDeduplication,\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>>;\n\n    const { serverQuery } = this.transform(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication\n        }),\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const byVariables = inFlightLinkObservables.get(serverQuery) || new Map();\n        inFlightLinkObservables.set(serverQuery, byVariables);\n\n        const varJson = canonicalStringify(variables);\n        observable = byVariables.get(varJson);\n\n        if (!observable) {\n          const concast = new Concast([\n            execute(link, operation) as Observable<FetchResult<T>>\n          ]);\n\n          byVariables.set(varJson, observable = concast);\n\n          concast.cleanup(() => {\n            if (byVariables.delete(varJson) &&\n                byVariables.size < 1) {\n              inFlightLinkObservables.delete(serverQuery);\n            }\n          });\n        }\n\n      } else {\n        observable = new Concast([\n          execute(link, operation) as Observable<FetchResult<T>>\n        ]);\n      }\n    } else {\n      observable = new Concast([\n        Observable.of({ data: {} } as FetchResult<T>)\n      ]);\n      context = this.prepareContext(context);\n    }\n\n    const { clientQuery } = this.transform(query);\n    if (clientQuery) {\n      observable = asyncMap(observable, result => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  private getResultsFromLink<TData, TVars>(\n    queryInfo: QueryInfo,\n    cacheWriteBehavior: CacheWriteBehavior,\n    options: Pick<WatchQueryOptions<TVars, TData>,\n      | \"variables\"\n      | \"context\"\n      | \"fetchPolicy\"\n      | \"errorPolicy\">,\n  ): Observable<ApolloQueryResult<TData>> {\n    const requestId = queryInfo.lastRequestId = this.generateRequestId();\n\n    return asyncMap(\n      this.getObservableFromLink(\n        queryInfo.document!,\n        options.context,\n        options.variables,\n      ),\n\n      result => {\n        const hasErrors = isNonEmptyArray(result.errors);\n\n        // If we interrupted this request by calling getResultsFromLink again\n        // with the same QueryInfo object, we ignore the old results.\n        if (requestId >= queryInfo.lastRequestId) {\n          if (hasErrors && options.errorPolicy === \"none\") {\n            // Throwing here effectively calls observer.error.\n            throw queryInfo.markError(new ApolloError({\n              graphQLErrors: result.errors,\n            }));\n          }\n          queryInfo.markResult(result, options, cacheWriteBehavior);\n          queryInfo.markReady();\n        }\n\n        const aqr: ApolloQueryResult<TData> = {\n          data: result.data,\n          loading: false,\n          networkStatus: queryInfo.networkStatus || NetworkStatus.ready,\n        };\n\n        if (hasErrors && options.errorPolicy !== \"ignore\") {\n          aqr.errors = result.errors;\n        }\n\n        return aqr;\n      },\n\n      networkError => {\n        const error = isApolloError(networkError)\n          ? networkError\n          : new ApolloError({ networkError });\n\n        // Avoid storing errors from older interrupted queries.\n        if (requestId >= queryInfo.lastRequestId) {\n          queryInfo.markError(error);\n        }\n\n        throw error;\n      },\n    );\n  }\n\n  public fetchQueryObservable<TData, TVars>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus = NetworkStatus.loading,\n  ): Concast<ApolloQueryResult<TData>> {\n    const query = this.transform(options.query).document;\n    const variables = this.getVariables(query, options.variables) as TVars;\n    const queryInfo = this.getQuery(queryId);\n\n    let {\n      fetchPolicy = \"cache-first\" as WatchQueryFetchPolicy,\n      errorPolicy = \"none\" as ErrorPolicy,\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = false,\n      context = {},\n    } = options;\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const fromVariables = (variables: TVars) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n      return this.fetchQueryByPolicy<TData, TVars>(\n        queryInfo,\n        normalized,\n        networkStatus,\n      );\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    this.fetchCancelFns.set(queryId, reason => {\n      // Delaying the cancellation using a Promise ensures that the\n      // concast variable has been initialized.\n      Promise.resolve().then(() => concast.cancel(reason));\n    });\n\n    // A Concast<T> can be created either from an Iterable<Observable<T>>\n    // or from a PromiseLike<Iterable<Observable<T>>>, where T in this\n    // case is ApolloQueryResult<TData>.\n    const concast = new Concast(\n      // If the query has @export(as: ...) directives, then we need to\n      // process those directives asynchronously. When there are no\n      // @export directives (the common case), we deliberately avoid\n      // wrapping the result of this.fetchQueryByPolicy in a Promise,\n      // since the timing of result delivery is (unfortunately) important\n      // for backwards compatibility. TODO This code could be simpler if\n      // we deprecated and removed LocalState.\n      this.transform(normalized.query).hasClientExports\n        ? this.localState.addExportedVariables(\n          normalized.query,\n          normalized.variables,\n          normalized.context,\n        ).then(fromVariables)\n        : fromVariables(normalized.variables!)\n    );\n\n    concast.cleanup(() => {\n      this.fetchCancelFns.delete(queryId);\n      applyNextFetchPolicy(options);\n    });\n\n    return concast;\n  }\n\n  public refetchQueries<TResult>({\n    updateCache,\n    include,\n    optimistic = false,\n    removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n    onQueryUpdated,\n  }: InternalRefetchQueriesOptions<ApolloCache<TStore>, TResult>\n  ): InternalRefetchQueriesMap<TResult> {\n    const includedQueriesById = new Map<string, {\n      oq: ObservableQuery<any>;\n      lastDiff?: Cache.DiffResult<any>;\n      diff?: Cache.DiffResult<any>;\n    }>();\n\n    if (include) {\n      this.getObservableQueries(include).forEach((oq, queryId) => {\n        includedQueriesById.set(queryId, {\n          oq,\n          lastDiff: this.getQuery(queryId).getDiff(),\n        });\n      });\n    }\n\n    const results: InternalRefetchQueriesMap<TResult> = new Map;\n\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: optimistic && removeOptimistic || false,\n\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq =\n            watch.watcher instanceof QueryInfo &&\n            watch.watcher.observableQuery;\n\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n\n              let result: TResult | boolean | Promise<ApolloQueryResult<any>> =\n                onQueryUpdated(oq, diff, lastDiff);\n\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              }\n\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n              }\n\n              // Prevent the normal cache broadcast of this result, since we've\n              // already handled it.\n              return false;\n            }\n\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });\n            }\n          }\n        },\n      });\n    }\n\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(({ oq, lastDiff, diff }, queryId) => {\n        let result: TResult | boolean | Promise<ApolloQueryResult<any>> | undefined;\n\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            const info = oq[\"queryInfo\"];\n            info.reset(); // Force info.getDiff() to read from cache.\n            diff = info.getDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n\n        if (result !== false) {\n          results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n        }\n\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  }\n\n  private fetchQueryByPolicy<TData, TVars>(\n    queryInfo: QueryInfo,\n    { query,\n      variables,\n      fetchPolicy,\n      refetchWritePolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n      notifyOnNetworkStatusChange,\n    }: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus: NetworkStatus,\n  ): ConcastSourcesIterable<ApolloQueryResult<TData>> {\n    const oldNetworkStatus = queryInfo.networkStatus;\n\n    queryInfo.init({\n      document: query,\n      variables,\n      networkStatus,\n    });\n\n    const readCache = () => queryInfo.getDiff(variables);\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus = queryInfo.networkStatus || NetworkStatus.loading,\n    ) => {\n      const data = diff.result;\n\n      if (__DEV__ &&\n          isNonEmptyArray(diff.missing) &&\n          !equal(data, {}) &&\n          !returnPartialData) {\n        invariant.debug(`Missing cache result fields: ${\n          diff.missing.map(m => m.path.join('.')).join(', ')\n        }`, diff.missing);\n      }\n\n      const fromData = (data: TData | undefined) => Observable.of({\n        data,\n        loading: isNetworkRequestInFlight(networkStatus),\n        networkStatus,\n        ...(diff.complete ? null : { partial: true }),\n      } as ApolloQueryResult<TData>);\n\n      if (data && this.transform(query).hasForcedResolvers) {\n        return this.localState.runResolvers({\n          document: query,\n          remoteResult: { data },\n          context,\n          variables,\n          onlyRunForcedResolvers: true,\n        }).then(resolved => fromData(resolved.data || void 0));\n      }\n\n      return fromData(data);\n    };\n\n    const cacheWriteBehavior =\n      fetchPolicy === \"no-cache\" ? CacheWriteBehavior.FORBID :\n      ( // Watched queries must opt into overwriting existing data on refetch,\n        // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n        networkStatus === NetworkStatus.refetch &&\n        refetchWritePolicy !== \"merge\"\n      ) ? CacheWriteBehavior.OVERWRITE\n        : CacheWriteBehavior.MERGE;\n\n    const resultsFromLink = () =>\n      this.getResultsFromLink<TData, TVars>(queryInfo, cacheWriteBehavior, {\n        variables,\n        context,\n        fetchPolicy,\n        errorPolicy,\n      });\n\n    const shouldNotify =\n      notifyOnNetworkStatusChange &&\n      typeof oldNetworkStatus === \"number\" &&\n      oldNetworkStatus !== networkStatus &&\n      isNetworkRequestInFlight(networkStatus);\n\n    switch (fetchPolicy) {\n    default: case \"cache-first\": {\n      const diff = readCache();\n\n      if (diff.complete) {\n        return [\n          resultsFromCache(diff, queryInfo.markReady()),\n        ];\n      }\n\n      if (returnPartialData || shouldNotify) {\n        return [\n          resultsFromCache(diff),\n          resultsFromLink(),\n        ];\n      }\n\n      return [\n        resultsFromLink(),\n      ];\n    }\n\n    case \"cache-and-network\": {\n      const diff = readCache();\n\n      if (diff.complete || returnPartialData || shouldNotify) {\n        return [\n          resultsFromCache(diff),\n          resultsFromLink(),\n        ];\n      }\n\n      return [\n        resultsFromLink(),\n      ];\n    }\n\n    case \"cache-only\":\n      return [\n        resultsFromCache(readCache(), queryInfo.markReady()),\n      ];\n\n    case \"network-only\":\n      if (shouldNotify) {\n        return [\n          resultsFromCache(readCache()),\n          resultsFromLink(),\n        ];\n      }\n\n      return [resultsFromLink()];\n\n    case \"no-cache\":\n      if (shouldNotify) {\n        return [\n          // Note that queryInfo.getDiff() for no-cache queries does not call\n          // cache.diff, but instead returns a { complete: false } stub result\n          // when there is no queryInfo.diff already defined.\n          resultsFromCache(queryInfo.getDiff()),\n          resultsFromLink(),\n        ];\n      }\n\n      return [resultsFromLink()];\n\n    case \"standby\":\n      return [];\n    }\n  }\n\n  private getQuery(queryId: string): QueryInfo {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId)!;\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}